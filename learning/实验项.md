- [搜索框](#搜索框)  
  + [便捷引入](#便捷引入)  
  + [搜索框的记忆及清除](#搜索框的记忆及清除)  
  + [根据用户输入请求相应数据](#根据用户输入请求相应数据)  
  + [点击查询](#点击查询) 
  + [默认格式化及ESlint修改](#默认格式化及ESlint修改) 

- [登录相关](#登录相关)  
  + [将token保存到sessionStorage](#将token保存到sessionStorage)

----

### 搜索框

#### 便捷引入

axios
```
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>
```

vue
```
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
```

#### 搜索框的记忆及清除  
> 可以建立一个数组，用于存储用户的输入数据，并使用 [v-for](https://github.com/SpringLoach/Vue/blob/main/learning/section1.md#v-for遍历数组和对象) 将数据展示到页面。  
> 
> 利用[表单输入绑定](https://github.com/SpringLoach/Vue/blob/main/learning/section1.md#表单输入绑定)获取用户输入的值，
当用户[敲下回车](https://github.com/SpringLoach/Vue/blob/main/learning/section1.md#v-on修饰符)时，将相应值添入到数组中即可展示。  

- 设置表单[默认值](https://github.com/SpringLoach/Vue/blob/main/learning/section1.md#表单输入绑定)   
- 添加数据  
- [删除](https://github.com/SpringLoach/origin-2021/blob/happy-day/JavaScript/常用方法速查.md#数组方法)某项数据  
- 移除所有数据  
- 当表单输入绑定的变量为空字符串时，使用 [placeholder](https://github.com/SpringLoach/origin-2021/blob/happy-day/css/html-速查.md#表单) 依旧可以设置提示  

#### 根据用户输入请求相应数据  
> 利用[表单输入绑定](https://github.com/SpringLoach/Vue/blob/main/learning/section1.md#表单输入绑定)的变量保存用户输入的值，
当用户[敲下回车](https://github.com/SpringLoach/Vue/blob/main/learning/section1.md#v-on修饰符)时，将变量作为查询键的值传入请求实例，发送请求。  

```
axios.get("https://xxx.xx/search?keyword=" + this.query)
```

#### 点击查询  
> 给相应的热门词都添加点击事件，在处理程序中给表单输入绑定的变量赋值，并发送请求。由于已经做好了数据展示的设计，此时会根据保存的数据**在页面直接渲染**。    

#### 默认格式化及ESlint修改  
> 可以新建 `.prettierrc` 修改默认格式化选项，以及在 `.eslintrc.js` 中禁用一些不必要的警告：[教程](https://www.bilibili.com/video/BV1EE411B7SU?p=27)   
----

### 登录相关

#### 将token保存到sessionStorage  
> 一般页面登陆成功后，服务器会返回 token 作为接下来的通信凭据，此时要在客户端将该 token 保存到会话存储中，直至网页关闭前，它都会保留。  

```
then(() => {
  window.sessionStorage.setItem("token", res.anywhere.token);
})
```

#### token原理  

1. 客户端：用户在登录页面输入用户名和密码进行登录    
2. 服务器：验证通过，会生成属于该用户的 `token` 并返回   
3. 客户端：存储 `token`，并在后续所有的请求中携带 `token`   
4. 服务端：通过验证 `token` 来辨认身份

#### 渲染登录组件  
> [配置](https://github.com/SpringLoach/Vue/blob/main/learning/section2.md#路由映射配置)路由映射及[重定向](https://github.com/SpringLoach/Vue/blob/main/learning/section2.md#路由的默认值和模式修改)，在 `main.js` 中挂载路由实例，并在根组件中决定需要渲染路由组件的[位置](https://github.com/SpringLoach/Vue/blob/main/learning/section2.md#路由映射配置)。

#### less的安装[使用](https://less.bootcss.com/#概览)  

安装到 Node.js  
```
npm install less-loader@7.3.0 less --save-dev
```

在组件中使用
```
/* Login.vue */
<style lang="less" scoped>
#login {background-color: #2b4b6b;}
</style>
```

- 将 normalize.css 导入 新创建的 `base.css`  
- 并将 `base.css`，导入到 `App.vue`

#### 表单失焦验证  
> 监听表单元素的 `blur` 事件，来[动态绑定](https://github.com/SpringLoach/Vue/blob/main/learning/section1.md#绑定class)样式。需要注意的是，如果用数组保存判断值，不能直接修改[数组](https://github.com/SpringLoach/Vue/blob/main/learning/section1.md#数组变更方法)。  

#### 表单的重置功能  
> 监听表单重置元素的点击，将对应的值赋值为空字符串，然后将修改后的数组赋值给数组本身触发检测。

#### 表单预验证  
> 监听表单的 `submit` 事件，适当的时候调用 `event.preventDefault()` 阻止表单提交。
> 
> 另外可以添加 `Toast` [插件](https://github.com/SpringLoach/Vue/blob/main/learning/section4.md#toast的插件封装)，只需将文件复制，并在 `main.js` 安装插件即可。    

:snowflake: 点击 `submit` 按钮时，会触发表单的 `submit` 事件，自动验证表单元素的必填项。  

#### 配置axios发起登录请求  
> [安装](https://github.com/SpringLoach/Vue/blob/main/learning/section3.md#axios框架的基本使用)axios，并新建 `request.js` [封装模块](https://github.com/SpringLoach/Vue/blob/main/learning/section3.md#模块封装)并创建实例，也可以设置[拦截器](https://github.com/SpringLoach/Vue/blob/main/learning/section3.md#拦截器)筛选数据。然后可以新建对应的请求文件，给实例传参，封装[方法](https://github.com/SpringLoach/Vue/blob/main/learning/section4.md#商品数据的请求和保存)。  

这里需要将用户的账号密码传入，可以预先将它们保存到同一个对象中，使用时就把它当作参数传入封装好的请求方法。  
```
export function getLogin(loginData) {
  return request({
    url: '/login',
    method: 'post',
    params: loginData
  })
}
```

:bug: 明明是 `post`，却使用了[params](https://github.com/SpringLoach/Vue/blob/main/learning/section3.md#axios的配置相关信息)进行传参。  

#### 从响应中获取token并保存
> 先将获取到的 token [保存](#将token保存到sessionStorage)，然后通过[代码跳转](https://github.com/SpringLoach/Vue/blob/main/learning/section2.md#通过代码跳转路由)到首页，需要[配置](https://github.com/SpringLoach/Vue/blob/main/learning/section2.md#路由映射配置)路由映射。  

#### 强制跳转到登录页  
> 对于没有登录，没在会话中保存 `token` 的用户，不能让其直接通过网址到其它页面。这能通过[导航守卫](https://github.com/SpringLoach/Vue/blob/main/learning/section2.md#全局导航守卫)实现。 

```
// return 在这里的作用是退出执行

/* router 下的 index.js */
router.beforeEach((to, from, next) => {
  if (to.path === '/login') {return next()};
  const State = window.sessionStorage.getItem('token');
  if (State) {
    return next()
  } else {
    next('/login')
  }
})
```

#### 退出登录  
> 当用户点击退出按钮时，清除会话中的 `token`，并回到登录页面。   

```
/* 删除指定数据 */
window.sessionStorage.removeItem("token");

/* 删除所有数据 */
window.sessionStorage.clear();
```

#### 将token添加到请求中  
> 需要授权的 API ，必须在请求头中使用 Authorization 字段提供 token 令牌。可以在[拦截器](https://github.com/SpringLoach/Vue/blob/main/learning/section3.md#拦截器)中实现。  

```
/* request.js */
instance.interceptors.request.use(config => {
  config.headers.Authorization = window.sessionStorage.getItem('token');
  return config;
}, err => {
  return err;
}) 
```

---

### 菜单

#### 获取菜单数据  
> 需要用对应的[接口](https://github.com/SpringLoach/Vue/blob/main/learning/项目需要/api接口文档.md#142-左侧菜单权限)请求数据。  

1. 在 `created` 钩子处请求数据，将方法定义到 `methods`。  
2. 在 `data` 中初始化变量，并在方法中用其接收相应的请求数据。  

很神奇的编码方式，定义的方法与引入的方法虽然同名，却不相冲突。  
```
import {getMenuList} from '@/network/home'

/* created */
this.getMenuList()

/* methods */
getMenuList() {
  getMenuList().then(res => {
    console.log(res);
  })
}
```

#### 菜单的点击模式  
> 主分类操作二级分类的展开关闭、同一时刻只能出现一个二级分类、二级分类激活项的记录。  

索引 | 说明
:-: | :-: 
Ⅰ | 不同子组件间的同名变量相互不影响
Ⅰ | 通过 `v-show` 控制二级菜单  
Ⅱ | 在父组监听子组点击。第二次点击以后、点击不同组件时，关闭上一个子组件的展开  
Ⅲ | 子组的二级分类被点击时，记录当前索引，再向父组通信
Ⅲ | 父组的处理程序可以从 `v-for` 获取传件子组的索引作参  
Ⅲ | 父组改变子组的激活状态

一些要点  

说明 
:-:
给组件添加原生事件处理程序需要后缀 `.native` 
`ref` 要放在子组件的模板标签上，才能拿到子组件内部的一些变量  
可以给菜单选项添加一个改变背景颜色的渐变效果
自定义属性和动态类都可传入表达式，也可以改写为方法  
通过动态属性，可以在不获取 DOM 的情况下改变样式  

#### 菜单的缩放和悬停  
> 可以动态给整体加个类，利用 less，可以在该类上较轻松地重构样式。

操作 | 说明
:-: | :- 
一级菜单布局 | 将不需要展示的部分隐藏
二级菜单布局 | 需要加一个 div 将其包裹，不能直接在选项上子绝父相，会重位
二级菜单布局 | 然后以该 div 作为子，进行子绝父相定位 
悬空二级菜单 | 监听一级菜单、二级菜单体的鼠标移入、移出事件来决定需要使用的样式 
悬空二级菜单 | 移入、移出共使用两个事件处理程序
悬空二级菜单 | 直接在包裹块中设置过渡效果
悬空二级菜单 | 可以在设置块展示后，定时不透明达到淡入效果
悬空二级菜单 | 可以在设置全透明后，定时隐藏块达到淡出效果

#### 实现部分区域路由  
> 在父组件中，布局好后，在需要的位置处使用路由 `<router-view/>`。在子路径变化时，会将对应的组件渲染到该处。  
> 
> 可以给当前路径添加默认[跳转路由](https://github.com/SpringLoach/Vue/blob/main/learning/section2.md#路由的默认值和模式修改)，来实现初始化。  


#### 路由跳转  
> 监听点击，通过代码跳转路由。由于每个页面的布局和功能不同，不能使用[动态路由](https://github.com/SpringLoach/Vue/blob/main/learning/section2.md#动态路由的使用)，而是直接用对应参数配置路由映射。

---

### 用户管理

#### 面包屑  
> 由于组件关系较远，可以通过状态管理传输数据。
> 
> 组件接收到的数据不能直接使用时，可以先在计算属性处理，再进行使用、布局。  

#### 动态添加搜索框的清除键  
> 根据绑定的数据决定是否 `v-show` 该元素。
> 
> 利用子绝父相和 `:hover` 动态显示。  

#### 表格数据的展示  
> 可以先在请求中将需要的数据结构梳理好，保存到 `this` 中，即把方法当作构造函数。当请求时，只需要创建新实例并保存到组件变量中即可。
> 
> 也可以在中间组件中，利用 `map` 函数将数据梳理。
> 
> 在中间组件中，向子传递自定义数据、请求数据。复杂的数据可以在子组件中添加插槽。  

#### 表格数据的切换  
> 由于表格展示的数据是由请求数据决定的，可以新建一个切页组件。在布局后，当发生对应事件时，通知父组件改变请求参数，并重新发送请求。  

重要功能 | 要点
:-: | :- 
上拉列表 | 利用子绝父相，悬停展现实现样式
上拉列表 | 动态绑定展示数，点击时，通知父组件配参请求
左右箭头 | 点击时，通知父组件配参请求   
左右箭头 | 两端禁用，动态绑定 `disabled` 属性和样式
数值跳转 | 根据总数/展示数取上整，动态决定渲染数量
数值跳转 | 添加最值情况，限制渲染数量
数值跳转 | 点击时，通知父组件配参请求
输入跳转 | `keyup.enter` 时，通父配参请求
输入跳转 | 限制两端情况  
其它 | 对象通知监测：`this.xx = {...this.xx}`
其它 | 无初始值的vue实例属性，监听存在问题

#### 提交状态修改    
> 由于操作项为在表格中遍历的某一项单元格，监听点击的时候，需要传入相应的索引值，判断是否为需求索引，再进行操作。 
> 
> 需要修改计算属性：在方法中更改 *data*，在计算属性中检测该 *data* 的值，处理后重置 *data*。   
>  
> 状态更改失败时，需将表格中的状态回退，即取反。  

:herb: 提交更改的请求时，都使用 `put` 方法？  

#### 实现搜索功能   
> 可以给查询按钮的点击、输入框的 `@keyup.enter` 添加搜索方法。  
> 
> 使用数组的 filter 方法遍历请求数据，判断其中的需求性是否包括绑定值。将新数组赋值给原请求数据。 

重要功能 | 要点
:-: | :- 
重新请求 | 搜索会改变原数据，搜索前需重新请求  
重新请求 | 在请求的解决程序中进行修改操作
重新请求 | 可以用辅助 *data* 判断是否需要操作  
其它 | 搜索时，需要重置页码

:bug: 由于数据是根据页码和展示条数进行请求，每次拿到的很可能都不是完整的数据，搜索受限。  

#### 思路-重写请求结构  
> 1. 通过响应返回的总数，重新将所有数据请求到一页中。  
> 
> 2. 在中间组建处理需要传入的参数，可以利用 `m + n*pagesize` 操作展示数组。    
> 
> 3. 若数据索引超出总数，便不推到展示数组。

#### 思路-请求数据过多    
> 一次请求固定的数据，通过页码记录当前请求页。  
> 
> 展示数应该存在倍数关系，以避免一个展示页需要不同的请求数据。
> 
> 过临界时，将下一个请求页的数据通过 `push` 和 `...` 添加到保存的数据中，并使页码自增。  

#### 思路-子组件复用  
> 只需要接收不同的数据时进行相同布局时，使用子组件的效果最好。  
> 
> 若涉及额外的样式、逻辑不同时，可以通过自定义属性作为开关，通过遍历索引决定是否在内部发射事件及动态绑类。  

#### 思路-多功能子组件 
> 数组的元素为对象，在遍历中，通过[条件渲染](https://github.com/SpringLoach/Vue/blob/main/learning/section1.md#条件渲染)获取元素的属性，从而具体决定需要渲染的东西，甚至是插槽。 
>
> 可以在对象中添加方法，从而在子组件中使用;也可以用其中的属性用于绑定表单。   
> 
> 元素也可以不是对象，可以在数组对应位置添加一个 `'diy'`，表示渲染插槽。    

#### 思路-子组件遍历项中绑动态事件和属性  
> 在 `v-if` 的方法中决定是否渲染、添加方法。
> 
> 给遍历项添加动态 `ref` 属性，传入方法。这样在方法内部就可以给该元素添加事件和属性。  

```
/* 父组件 */
// 传给自定义属性  
data() {
  return {
    text: {shijian: 'click', href: 'https://www.bilibili.com/', is: true}
  }
}

/* 子组件 */
<a v-if='check(text, "a")' ref="a">bilibili</a>

props: {
  text: {
    type: Object,
    default() {
      return {}
    }
  }
},
methods: {
  check(text, el) {
    if(this.$refs[el]) {
      console.log(this.$refs[el]);
      this.$refs[el].addEventListener(text.shijian, () => {
        alert('get');
      })
      this.$refs[el].setAttribute("href", text.href)
    }       
    if(text.is) {
      return true;
    }
  }
}
```
:bug: 在 `v-for` 的环境下，通过 `ref` 获取到的不是元素，而是一个包裹元素的数组。  
:bug: 需要设置一个异步来添加属性等，否则元素都没被添加到文档。  

#### 思路-间距悬浮  
> 通过添加透明、固定大小的伪元素，解决存在间距时，无法悬停的问题。  

#### 抽离普通组件
> 在某几个组件中，都用到了相同的外围布局，可以抽离为普通组件，提供插槽，导入镶嵌使用。  

----

### 添加用户  
> 由于有很多地方需要该表单，总体样式一致，内容不同，所以可以把样式部分抽离成单独组件。  
> 
> 表单及表单元素应该写为单独组件，因为每个表单的具体内容都是不一样的。  

重要功能 | 要点
:-: | :- 
样式组件 | 图片模态[参考](https://www.w3school.com.cn/tiy/t.asp?f=css_image_modal_js)  
样式组件 | 不能使用 ID 添加样式，优先级太高，后面无法覆盖   
样式组件 | 不使用 `scoped` 以透出样式  
表单组件 | 包括提交和取消元素，方便处理逻辑   
表单组件 | 可以创建 `errVertify` 对象用于验证表单  
其它 | 嵌套深。通过 Vuex 管理窗口的打开状态   

----

表单输入框外边距内边距，holder；
可以给元素设置部分圆角效果；
删除 `a` 标签的 `href` 属性去除默认跳转
通过 `cursor` 属性添加箭头；
curson/placeholder/transform:rotate仅对block、inline-block生效
动态data，自建，双向绑定上有问题
keyup
动态绑定能感应到：this.xx = {...this.xx}






 



  
  



 
  












